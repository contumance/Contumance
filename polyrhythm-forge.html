<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>The Polyrhythm Forge ‚Äî Re:sonance</title>
  <meta name="description" content="Forge polyrhythms and polymeters in the style of Meshuggah. Ring visualization, WebAudio, Euclidean patterns, swing, panning, palm-mutes, and MIDI export." />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>‚ô™</text></svg>">
  <link rel="stylesheet" href="assets/kindle.css">
  <style>
    .controls{ display:grid; gap:.6rem; grid-template-columns: repeat(auto-fit, minmax(180px,1fr)); }
    .row{ display:flex; gap:.5rem; flex-wrap:wrap; align-items:center; }
    label{ font-size:12px; opacity:.9; }
    input, select, button{
      appearance:none; border:1px solid var(--accent); background:transparent; color:var(--ink);
      padding:.55rem .6rem; border-radius:.5rem; font-family:inherit; font-size:.92rem; line-height:1;
      min-width:0; outline:none;
    }
    input[type="range"]{ width:160px; }
    button.primary{ background:var(--ink); color:var(--paper); border-color:var(--ink); }
    button:focus-visible, input:focus-visible, select:focus-visible{ outline:2px dashed var(--accent); outline-offset:2px; }

    .stage{ border:1px solid var(--accent); border-radius:.6rem; background:transparent; margin-top:12px; padding:.5rem; }
    .stage canvas{ width:100%; height:auto; display:block; aspect-ratio:1/1; }

    .timeline{ border:1px solid var(--accent); border-radius:.6rem; background:transparent; margin-top:12px; padding:.5rem; }
    .timeline canvas{ width:100%; height:auto; display:block; aspect-ratio:5/1; }

    .tracklist{ margin-top:12px; display:grid; gap:.5rem; }
    .track{
      border:1px solid var(--accent); border-radius:.6rem; padding:.6rem .6rem .65rem;
      display:grid; gap:.5rem; grid-template-columns: 1fr;
    }
    .track .line{ display:flex; gap:.5rem; flex-wrap:wrap; align-items:center; }
    .tag{ border:1px solid var(--accent); border-radius:999px; padding:.1rem .5rem; font-size:.78rem; color:var(--muted); }
  </style>
</head>
<body>
  <main>
    <div class="topbar">
      <nav class="breadcrumb" aria-label="Breadcrumb">
        <a href="index.html">‚Üê Back to index</a>
      </nav>
      <button class="theme-toggle" id="themeToggle" type="button" aria-label="Toggle theme" title="Toggle theme">üåì</button>
    </div>

    <header>
      <h1>The Polyrhythm Forge</h1>
      <div class="subtitle">Forge polyrhythms and polymeters with ring + loop views ‚Äî Mesh-ish + palm-mutes + MIDI export.</div>
    </header>

    <details class="panel" open>
      <summary>Engine & Presets</summary>
      <div class="panel-body">
        <div class="controls" role="group" aria-label="Polyrhythm controls">
          <div class="row" style="gap:.7rem">
            <label>Tempo</label>
            <input id="tempo" type="number" min="20" max="300" value="120" style="width:5.5rem">
            <label>Bar length</label>
            <select id="barLen">
              <option value="4" selected>1 bar = 4 quarter notes (4/4)</option>
              <option value="3">3 quarter notes (3/4)</option>
              <option value="5">5 quarter notes (5/4)</option>
              <option value="7">7 quarter notes (7/4)</option>
            </select>
          </div>

          <div class="row">
            <label>Mode</label>
            <select id="mode">
              <option value="polymeter" selected>Polymeter (common step)</option>
              <option value="polyrhythm">Polyrhythm (common cycle)</option>
            </select>

            <label>Swing</label>
            <input id="swing" type="range" min="0" max="0.6" step="0.01" value="0">
            <span class="tag" id="swingVal">swing: 0%</span>
          </div>

          <div class="row">
            <button id="play" class="primary" type="button">Play</button>
            <button id="stop" type="button">Stop</button>
            <button id="addTrack" type="button">+ Track</button>

            <!-- Presets agrupados desde JSON externo -->
            <select id="preset" title="Load a preset from polyrhythm-presets.json">
              <option value="">‚Äî Load preset ‚Äî</option>
              <!-- grupos/opciones se agregan por JS -->
            </select>

            <button id="export" type="button">Export JSON</button>
            <button id="import" type="button">Import JSON</button>
          </div>

          <hr>

          <div class="row">
            <label>Instrument</label>
            <select id="instMode" title="What each hit triggers">
              <option value="drums" selected>Drums (GM Channel 10)</option>
              <option value="guitar">Guitar Palm-mute</option>
              <option value="bass">Bass Palm-mute</option>
            </select>
            <label>Root note</label>
            <input id="rootNote" type="text" value="E2" style="width:5.5rem" title="E2, D#3 or MIDI number">
            <button id="exportMidi" type="button">Export MIDI</button>
            <span class="tag">SMF Type-0</span>
          </div>
        </div>
      </div>
    </details>

    <section class="stage" aria-label="Ring visual">
      <canvas id="ringCanvas" width="1000" height="1000" aria-hidden="true"></canvas>
    </section>

    <section class="timeline" aria-label="Loop View">
      <canvas id="lineCanvas" width="1400" height="280" aria-hidden="true"></canvas>
    </section>

    <section class="tracklist" id="tracks" aria-label="Tracks"></section>

    <footer>
      <a class="btn" href="https://buymeacoffee.com/Contumance" target="_blank" rel="noopener noreferrer">
        <svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
          <path d="M4 8h14.5a2 2 0 0 1 0 4H18l-1 5a4 4 0 0 1-3.95 3.3H8.95A4 4 0 0 1 5 17l-1-9z"/>
          <path d="M3 8h17"/>
          <path d="M7 4h6"/>
        </svg>
        <span>Buy me a coffee</span>
      </a>
      <span class="note">Fuel the craft. Inspire the next page.</span>
      <span>¬© <span id="y"></span> Re:sonance <small class="byline">by <em>Contumance</em></small></span>
    </footer>
  </main>

  <script>
    /* ===== Theme ===== */
    (function () {
      const KEY = 'theme-preference';
      const root = document.documentElement;
      const btn = document.getElementById('themeToggle');
      function setIcon(){ btn.textContent = '‚óë'; }
      function apply(mode){ root.classList.toggle('theme-dark', mode === 'dark'); setIcon(mode); }
      function getPreferred(){
        const saved = localStorage.getItem(KEY);
        if (saved === 'light' || saved === 'dark') return saved;
        return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
      }
      let current = getPreferred(); apply(current);
      btn.addEventListener('click', () => {
        current = current === 'dark' ? 'light' : 'dark';
        localStorage.setItem(KEY, current); apply(current);
      });
      document.getElementById('y').textContent = new Date().getFullYear();
    })();

    /* ===== Utils ===== */
    const $ = s => document.querySelector(s);
    const $$ = s => Array.from(document.querySelectorAll(s));
    function clamp(v,min,max){ return Math.min(max, Math.max(min, v)); }
    const NOTE_PC = { "C":0,"C#":1,"Db":1,"D":2,"D#":3,"Eb":3,"E":4,"F":5,"F#":6,"Gb":6,"G":7,"G#":8,"Ab":8,"A":9,"A#":10,"Bb":10,"B":11 };

    function midiFromInput(txt){
      if(!txt) return 40; // E2
      txt = String(txt).trim();
      if(/^\d+$/.test(txt)) return clamp(parseInt(txt,10), 0, 127);
      const m = txt.match(/^([A-Ga-g])([#b]?)(-?\d)$/);
      if(!m){ return 40; }
      const name = m[1].toUpperCase() + (m[2]||'');
      const oct = parseInt(m[3],10);
      const pc = NOTE_PC[name]; if(pc==null) return 40;
      return (oct+1)*12 + pc;
    }

    /* ===== WebAudio Engine ===== */
    let AC = null, master, lookaheadId = null;
    const schedule = [];
    const tracks = [];
    let isPlaying = false;
    let startAt = 0, visStart = 0;
    const lookahead = 0.025, scheduleAhead = 0.15;

    function getAC(){
      if(!AC){
        AC = new (window.AudioContext || window.webkitAudioContext)();
        master = AC.createGain();
        master.gain.value = 0.9;
        master.connect(AC.destination);
      }
      if(AC.state === 'suspended') AC.resume();
      return AC;
    }
    function mkGain(v=1){ const g = AC.createGain(); g.gain.value = v; return g; }
    function mkPanner(p=0){ const pn = AC.createStereoPanner ? AC.createStereoPanner() : null; if(pn) pn.pan.value = p; return pn; }

    /* ----- Drum voices ----- */
    function playClick(when, vol=1, pan=0){ const ac = getAC(); const o = ac.createOscillator(), g = mkGain(0.0001), pn=mkPanner(pan);
      o.type='square'; o.frequency.value=2000; g.gain.setValueAtTime(0.0001, when);
      g.gain.exponentialRampToValueAtTime(vol, when+0.002); g.gain.exponentialRampToValueAtTime(0.0001, when+0.04);
      (pn?o.connect(g).connect(pn).connect(master):o.connect(g).connect(master)); o.start(when); o.stop(when+0.06);
    }
    function playHat(when, vol=1, pan=0){ const ac = getAC();
      const N = 2*ac.sampleRate*0.05, buf = ac.createBuffer(1,N,ac.sampleRate), d=buf.getChannelData(0);
      for(let i=0;i<N;i++) d[i]=Math.random()*2-1;
      const src=ac.createBufferSource(); src.buffer=buf; const hp=ac.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=6000;
      const g=mkGain(0.0001), pn=mkPanner(pan); g.gain.setValueAtTime(0.0001, when); g.gain.linearRampToValueAtTime(vol, when+0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, when+0.05); src.connect(hp).connect(g); (pn?g.connect(pn).connect(master):g.connect(master));
      src.start(when); src.stop(when+0.06);
    }
    function playSnare(when, vol=1, pan=0){ const ac = getAC();
      const o=ac.createOscillator(); o.type='triangle'; o.frequency.value=220; const g1=mkGain(0.0001);
      g1.gain.setValueAtTime(0.0001, when); g1.gain.linearRampToValueAtTime(vol*0.7, when+0.006); g1.gain.exponentialRampToValueAtTime(0.0001, when+0.15);
      const N=2*ac.sampleRate*0.12, buf=ac.createBuffer(1,N,ac.sampleRate), d=buf.getChannelData(0); for(let i=0;i<N;i++) d[i]=(Math.random()*2-1)*(1-i/N);
      const n=ac.createBufferSource(); n.buffer=buf; const bp=ac.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1800; bp.Q.value=0.6;
      const g2=mkGain(0.0001); g2.gain.setValueAtTime(0.0001, when); g2.gain.linearRampToValueAtTime(vol*0.6, when+0.003); g2.gain.exponentialRampToValueAtTime(0.0001, when+0.12);
      const pn=mkPanner(pan); if(pn){ o.connect(g1).connect(pn).connect(master); n.connect(bp).connect(g2).connect(pn); pn.connect(master); }
      else { o.connect(g1).connect(master); n.connect(bp).connect(g2).connect(master); }
      o.start(when); o.stop(when+0.2); n.start(when); n.stop(when+0.15);
    }
    function playKick(when, vol=1, pan=0){ const ac = getAC();
      const o=ac.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(80, when); o.frequency.exponentialRampToValueAtTime(35, when+0.08);
      const g=mkGain(0.0001), pn=mkPanner(pan); g.gain.setValueAtTime(0.0001, when); g.gain.linearRampToValueAtTime(vol, when+0.005); g.gain.exponentialRampToValueAtTime(0.0001, when+0.2);
      (pn?o.connect(g).connect(pn).connect(master):o.connect(g).connect(master)); o.start(when); o.stop(when+0.22);
    }
    function playClave(when, vol=1, pan=0){ const ac = getAC(); const o=ac.createOscillator(); o.type='square'; o.frequency.value=1000;
      const g=mkGain(0.0001), pn=mkPanner(pan); g.gain.setValueAtTime(0.0001, when); g.gain.exponentialRampToValueAtTime(vol, when+0.002); g.gain.exponentialRampToValueAtTime(0.0001, when+0.07);
      (pn?o.connect(g).connect(pn).connect(master):o.connect(g).connect(master)); o.start(when); o.stop(when+0.08);
    }
    const SOUND_MAP = { click:playClick, hat:playHat, snare:playSnare, kick:playKick, clave:playClave };

    /* ----- Palm-mute voices (guitar/bass) ----- */
    function midiToFreq(m){ return 440 * Math.pow(2, (m - 69)/12); }

    function playPalm(when, midi=40, vol=1, pan=0, isBass=false){
      const ac = getAC();
      const o1 = ac.createOscillator(); o1.type = 'sawtooth';
      const o2 = ac.createOscillator(); o2.type = 'triangle';
      const lp = ac.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = isBass ? 1200 : 1800; lp.Q.value = 0.6;
      const g = mkGain(0.0001); const pn = mkPanner(pan);

      const f = midiToFreq(midi);
      o1.frequency.value = f; o2.frequency.value = f;

      const a = 0.002, d = 0.06, r = 0.06;
      g.gain.setValueAtTime(0.0001, when);
      g.gain.linearRampToValueAtTime(vol, when + a);
      g.gain.exponentialRampToValueAtTime(0.0001, when + a + d + r);

      o1.connect(lp); o2.connect(lp); lp.connect(g); (pn ? g.connect(pn).connect(master) : g.connect(master));
      o1.start(when); o2.start(when);
      o1.stop(when + a + d + r + 0.02); o2.stop(when + a + d + r + 0.02);
    }

    /* ===== Pattern helpers (Euclidean) ===== */
    function clampInt(v, lo, hi){ return Math.max(lo, Math.min(hi, v|0)); }

    // Rota el patr√≥n para que, si hay silencios, el/los 0 queden al final (ej: 3 en 4 => 1,1,1,0)
    function rotateSilenceToEnd(arr){
      if(!arr || !arr.length) return arr;
      let pattern = arr.slice();
      const hasZero = pattern.includes(0);
      if(!hasZero) return pattern; // todo hits
      // mover hasta que el √∫ltimo sea 0
      let guard = 0;
      while(pattern[pattern.length-1] !== 0 && guard < pattern.length+1){
        pattern.push(pattern.shift());
        guard++;
      }
      // asegurar que el primero sea 1
      guard = 0;
      while(pattern[0] !== 1 && guard < pattern.length+1){
        pattern.push(pattern.shift());
        guard++;
      }
      return pattern;
    }

    function euclidean(steps, hits){
      steps = clampInt(steps,1,256); hits = clampInt(hits,0,steps);
      // Bjorklund simple + rotaci√≥n ‚Äúbatero-friendly‚Äù
      let pattern = new Array(steps).fill(0);
      for(let i=0;i<hits;i++){ pattern[i] = 1; }
      let counts = new Array(steps).fill(0);
      for (let i=0;i<steps;i++){ counts[i]=(i<hits)?1:0; }
      let a = hits, b = steps - hits;
      let groups = counts.map(v => [v]);
      while (a > 0 && b > 0){
        const len = Math.min(a, b);
        for (let i=0;i<len;i++){ groups[i] = groups[i].concat(groups.pop()); }
        if (a > b) a = a - b; else b = b - a;
      }
      pattern = groups.flat();
      return rotateSilenceToEnd(pattern);
    }

    /* ===== Tracks UI / State ===== */
    function makeTrack(opts={}){
      const t = {
        id: crypto.randomUUID(),
        name: opts.name || 'Track',
        steps: opts.steps ?? 16,
        hits: opts.hits ?? 8,
        offset: opts.offset ?? 0,
        sound: opts.sound || 'click',
        note: opts.note || '',
        pan: opts.pan ?? 0,
        volume: opts.volume ?? 0.9,
        accent: opts.accent || (opts.sound==='hat' ? 'alt' : 'none'), // 'none' | 'alt'
        mute: !!opts.mute,
        solo: !!opts.solo,
        pattern: [],
        _playCount: 0,    // para alternar acentos en tiempo real
        _midiCount: 0     // para alternar acentos en export MIDI
      };
      t.pattern = euclidean(t.steps, t.hits);
      tracks.push(t);
      renderTrackUI(t);
      return t;
    }

    function renderTrackUI(t){
      const wrap = document.createElement('div');
      wrap.className = 'track'; wrap.dataset.id = t.id;
      wrap.innerHTML = `
        <div class="line">
          <strong>${t.name}</strong>
          <span class="tag">steps: <b class="stepsLab">${t.steps}</b></span>
          <span class="tag">hits: <b class="hitsLab">${t.hits}</b></span>
          <span class="tag">offset: <b class="offLab">${t.offset}</b></span>
          <span class="tag sndTag">sound: <b class="sndLab">${t.sound}</b></span>
          <span class="tag noteTag" style="display:none">note: <b class="noteLab">${t.note||'-'}</b></span>
          <span class="tag accTag" ${t.sound==='hat'?'':'style="display:none"'}>accent: <b class="accLab">${t.accent}</b></span>
        </div>
        <div class="line">
          <label>Steps</label><input class="steps" type="number" min="1" max="64" value="${t.steps}" style="width:5rem">
          <label>Hits</label><input class="hits" type="number" min="0" max="64" value="${t.hits}" style="width:5rem">
          <label>Offset</label><input class="offset" type="number" min="0" max="128" value="${t.offset}" style="width:5rem">

          <label class="labSound">Sound</label>
          <select class="sound">
            <option ${t.sound==='kick'?'selected':''} value="kick">kick</option>
            <option ${t.sound==='snare'?'selected':''} value="snare">snare</option>
            <option ${t.sound==='hat'?'selected':''} value="hat">hat</option>
            <option ${t.sound==='clave'?'selected':''} value="clave">clave</option>
            <option ${t.sound==='click'?'selected':''} value="click">click</option>
          </select>

          <label class="labAccent" ${t.sound==='hat'?'':'style="display:none"'}>Accent</label>
          <select class="accent" ${t.sound==='hat'?'':'style="display:none"'}>
            <option ${t.accent==='none'?'selected':''} value="none">none</option>
            <option ${t.accent==='alt'?'selected':''} value="alt">alt (soft/hard)</option>
          </select>

          <label class="labNote" style="display:none">Note</label>
          <input class="note" type="text" value="${t.note}" placeholder="E2 / 40" style="width:5.5rem; display:none">

          <label>Pan</label><input class="pan" type="range" min="-1" max="1" step="0.01" value="${t.pan}">
          <label>Vol</label><input class="vol" type="range" min="0" max="1.2" step="0.01" value="${t.volume}">
        </div>
        <div class="line">
          <button class="mute">${t.mute?'Unmute':'Mute'}</button>
          <button class="solo">${t.solo?'Unsolo':'Solo'}</button>
          <button class="delete">Delete</button>
        </div>
      `;
      $('#tracks').appendChild(wrap);

      const q = sel => wrap.querySelector(sel);
      q('.steps').addEventListener('change', e => { t.steps = Math.max(1, Math.min(64, e.target.value|0)); t.pattern = euclidean(t.steps, t.hits); q('.stepsLab').textContent = t.steps; });
      q('.hits').addEventListener('change', e => { t.hits = Math.max(0, Math.min(64, e.target.value|0)); t.pattern = euclidean(t.steps, t.hits); q('.hitsLab').textContent = t.hits; });
      q('.offset').addEventListener('change', e => { t.offset = Math.max(0, Math.min(128, e.target.value|0)); q('.offLab').textContent = t.offset; });
      q('.sound').addEventListener('change', e => {
        t.sound = e.target.value; q('.sndLab').textContent = t.sound;
        const isHat = t.sound==='hat';
        q('.labAccent').style.display = isHat ? '' : 'none';
        q('.accent').style.display = isHat ? 'inline-block' : 'none';
        q('.accTag').style.display = isHat ? '' : 'none';
        if(isHat && t.accent==='none') t.accent='alt'; // por defecto en hat
        q('.accLab').textContent = t.accent;
        // toggle Note inputs for non-drums handled elsewhere
      });
      q('.accent').addEventListener('change', e => { t.accent = e.target.value; q('.accLab').textContent = t.accent; });
      q('.note').addEventListener('change', e => { t.note = e.target.value.trim(); q('.noteLab').textContent = t.note||'-'; });
      q('.pan').addEventListener('input', e => { t.pan = parseFloat(e.target.value)||0; });
      q('.vol').addEventListener('input', e => { t.volume = parseFloat(e.target.value)||0.8; });

      q('.mute').addEventListener('click', () => { t.mute = !t.mute; q('.mute').textContent = t.mute?'Unmute':'Mute'; });
      q('.solo').addEventListener('click', () => { t.solo = !t.solo; q('.solo').textContent = t.solo?'Unsolo':'Solo'; });
      q('.delete').addEventListener('click', () => {
        const idx = tracks.findIndex(x=>x.id===t.id);
        if(idx>=0){ tracks.splice(idx,1); wrap.remove(); }
      });

      function refreshForInst(){
        const inst = $('#instMode').value;
        const showDrums = (inst==='drums');
        q('.labSound').style.display = showDrums ? '' : 'none';
        q('.sound').style.display = showDrums ? 'inline-block' : 'none';
        q('.sndTag').style.display = showDrums ? '' : 'none';

        q('.labAccent').style.display = showDrums && t.sound==='hat' ? '' : 'none';
        q('.accent').style.display = showDrums && t.sound==='hat' ? 'inline-block' : 'none';
        q('.accTag').style.display = showDrums && t.sound==='hat' ? '' : 'none';

        q('.labNote').style.display = showDrums ? 'none' : '';
        q('.note').style.display = showDrums ? 'none' : 'inline-block';
        q('.noteTag').style.display = showDrums ? 'none' : '';
      }
      $('#instMode').addEventListener('change', refreshForInst);
      refreshForInst();
    }

    /* ===== Transport / Scheduler ===== */
    const ringCanvas = document.getElementById('ringCanvas');
    const ringCtx = ringCanvas.getContext('2d');
    const lineCanvas = document.getElementById('lineCanvas');
    const lineCtx = lineCanvas.getContext('2d');

    function now(){ return getAC().currentTime; }
    function enqueue(when, cb){ schedule.push({when, cb}); schedule.sort((a,b)=>a.when-b.when); }
    function pump(){ const t=now(); while(schedule.length && schedule[0].when <= t + scheduleAhead){ const job=schedule.shift(); try{job.cb(job.when);}catch(e){console.error(e);} } }
    function loop(){ pump(); }

    function resetCounters(){
      tracks.forEach(t=>{ t._playCount = 0; });
    }

    function start(){
      const ac = getAC();
      isPlaying = true;
      startAt = ac.currentTime + 0.05;
      visStart = performance.now() + 50;
      resetCounters();
      if(lookaheadId) clearInterval(lookaheadId);
      lookaheadId = setInterval(loop, lookahead*1000);
      requestAnimationFrame(drawAll);
      scheduleNext();
    }
    function stop(){ isPlaying=false; clearInterval(lookaheadId); lookaheadId=null; drawAll(); }

    function hatAccentFactor(t){
      if(t.accent !== 'alt') return 1.0;
      const k = t._playCount % 2; // 0 soft, 1 hard
      return k===0 ? 0.65 : 1.0;
    }

    function scheduleNext(){
      if(!isPlaying) return;
      const ac = getAC();
      const tp = parseFloat($('#tempo').value)||120;
      const barBeats = parseFloat($('#barLen').value)||4;
      const barDur = (60/tp)*barBeats;
      const mode = $('#mode').value;
      const swing = parseFloat($('#swing').value)||0;
      const inst = $('#instMode').value;
      const rootMidi = midiFromInput($('#rootNote').value||'E2');

      const tNow = ac.currentTime;
      const windowStart = Math.max(tNow, startAt);
      const windowEnd = tNow + scheduleAhead;

      tracks.forEach(tr => {
        const soloed = tracks.some(x=>x.solo);
        const audible = (!soloed || tr.solo) && !tr.mute && tr.volume>0.001;
        if(!audible) return;

        const steps = Math.max(1, Math.min(256, tr.steps|0));
        const patt = tr.pattern.length ? tr.pattern : euclidean(tr.steps, tr.hits);

        const stepDur = (mode==='polyrhythm') ? (barDur/steps) : ((60/tp)/4);

        const sinceStart = Math.max(0, windowStart - startAt);
        const firstStepIdx = Math.floor(sinceStart/stepDur);
        const offsetSteps = ((tr.offset%steps)+steps)%steps;

        const n = Math.ceil((windowEnd - windowStart)/stepDur)+2;
        for(let i=0;i<n;i++){
          const idx = firstStepIdx + i;
          const when = startAt + idx*stepDur;

          const isEven = (idx%2)===1;
          const swingOff = isEven ? swing*stepDur*0.5 : 0;

          const sIdx = (idx + offsetSteps) % steps;
          if(!patt[sIdx]) continue;

          enqueue(when + swingOff, (w)=>{
            if(inst==='drums'){
              let vol = tr.volume;
              if(tr.sound==='hat'){ vol *= hatAccentFactor(tr); tr._playCount++; }
              const fn = SOUND_MAP[tr.sound] || SOUND_MAP.click;
              fn(w, vol, tr.pan);
            }else{
              const isBass = (inst==='bass');
              const midi = tr.note ? midiFromInput(tr.note) : rootMidi;
              playPalm(w, midi, tr.volume, tr.pan, isBass);
            }
          });
        }
      });

      setTimeout(scheduleNext, (scheduleAhead*0.5)*1000);
    }

    /* ===== Visuals ===== */
    function drawAll(){
      drawRings();
      drawTimeline();
      if(isPlaying) requestAnimationFrame(drawAll);
    }

    function drawRings(){
      const ctx = ringCtx, canvas = ringCanvas;
      const W = canvas.width, H = canvas.height;
      ctx.clearRect(0,0,W,H);
      const cx = W/2, cy = H/2;

      const TP = parseFloat($('#tempo').value)||120;
      const barBeats = parseFloat($('#barLen').value)||4;
      const barDur = (60/TP)*barBeats;
      const mode = $('#mode').value;

      const nowPerf = performance.now();
      const elapsed = isPlaying ? (nowPerf - visStart)/1000 : 0;

      const radiusBase = Math.min(W,H)*0.40, ringGap = 38;
      const styles = getComputedStyle(document.documentElement);
      const ink = styles.getPropertyValue('--ink').trim() || '#222';
      const rule = styles.getPropertyValue('--rule').trim() || '#ccc';
      const muted = styles.getPropertyValue('--muted').trim() || '#777';

      // Start marker (triangulito arriba)
      ctx.save();
      ctx.fillStyle = muted; ctx.beginPath();
      ctx.moveTo(cx, cy - radiusBase - 16);
      ctx.lineTo(cx - 8, cy - radiusBase - 28);
      ctx.lineTo(cx + 8, cy - radiusBase - 28);
      ctx.closePath(); ctx.fill();
      ctx.restore();

      ctx.save(); ctx.fillStyle = muted; ctx.font = '16px ui-serif, Georgia, serif'; ctx.textAlign='center';
      ctx.fillText(`${mode==='polyrhythm'?'Polyrhythm (common cycle)':'Polymeter (common step)'} ¬∑ ${TP} BPM`, cx, cy - radiusBase - tracks.length*ringGap*0.08 - 36);
      ctx.restore();

      tracks.forEach((tr,i)=>{
        const steps = Math.max(1, Math.min(256, tr.steps|0));
        const patt = tr.pattern.length ? tr.pattern : euclidean(tr.steps, tr.hits);
        const r = radiusBase - i*ringGap;

        ctx.save(); ctx.strokeStyle = rule; ctx.lineWidth = 1.2; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke(); ctx.restore();

        const stepDur = (mode==='polyrhythm') ? (barDur/steps) : ((60/TP)/4);

        for(let s=0;s<steps;s++){
          const ang = -Math.PI/2 + (s/steps)*Math.PI*2;
          const px = cx + Math.cos(ang)*r, py = cy + Math.sin(ang)*r;
          const on = patt[s];
          ctx.save(); ctx.beginPath(); ctx.arc(px,py,on?6:3.2,0,Math.PI*2);
          ctx.fillStyle = on ? ink : muted; ctx.globalAlpha = on ? 0.95 : 0.45; ctx.fill(); ctx.restore();
        }

        if(isPlaying){
          let phase;
          if(mode==='polyrhythm'){ phase = (elapsed % barDur) / barDur; }
          else{
            const stepDurCommon = (60/TP)/4;
            const totalSteps = Math.floor(elapsed/stepDurCommon);
            const frac = (elapsed%stepDurCommon)/stepDurCommon;
            phase = ((totalSteps + frac) / steps) % 1;
          }
          const ang = -Math.PI/2 + phase*Math.PI*2;
          const px = cx + Math.cos(ang)*r, py = cy + Math.sin(ang)*r;
          ctx.save(); ctx.fillStyle = ink; ctx.globalAlpha = 0.25; ctx.beginPath(); ctx.arc(px,py,11,0,Math.PI*2); ctx.fill(); ctx.restore();
        }

        ctx.save(); ctx.fillStyle = muted; ctx.font = '12px ui-serif, Georgia, serif'; ctx.textAlign='center';
        const inst = $('#instMode').value;
        const tag = (inst==='drums') ? `${tr.sound}${tr.sound==='hat' && tr.accent!=='none' ? '¬∑acc' : ''}` : `${tr.note||$('#rootNote').value||'E2'}`;
        ctx.fillText(`${tr.name} ¬∑ ${tr.steps}:${tr.hits} ¬∑ pan ${tr.pan>=0?'+':''}${tr.pan.toFixed(2)} ¬∑ ${tag}`, cx, cy - r - 10);
        ctx.restore();
      });
    }

    function drawTimeline(){
      const ctx = lineCtx, canvas = lineCanvas;
      const W = canvas.width, H = canvas.height;
      ctx.clearRect(0,0,W,H);

      const TP = parseFloat($('#tempo').value)||120;
      const barBeats = parseFloat($('#barLen').value)||4;
      const barDur = (60/TP)*barBeats;
      const mode = $('#mode').value;

      const nowPerf = performance.now();
      const elapsed = isPlaying ? (nowPerf - visStart)/1000 : 0;

      const styles = getComputedStyle(document.documentElement);
      const ink = styles.getPropertyValue('--ink').trim() || '#222';
      const rule = styles.getPropertyValue('--rule').trim() || '#ccc';
      const muted = styles.getPropertyValue('--muted').trim() || '#777';

      const laneH = Math.max(24, Math.floor((H-40)/Math.max(1,tracks.length)))|0; // padding top 20, bottom 20
      const top = 20;

      // grid de compases
      ctx.save();
      ctx.strokeStyle = rule; ctx.lineWidth = 1;
      const barsToShow = 2; // 2 ciclos
      for(let b=0;b<=barsToShow;b++){
        const x = (b/barsToShow)*W;
        ctx.beginPath(); ctx.moveTo(x, 10); ctx.lineTo(x, H-10); ctx.stroke();
        if(b<barsToShow){
          ctx.fillStyle = muted; ctx.font='12px ui-serif, Georgia, serif';
          ctx.fillText(`Bar ${b+1}`, x+6, 16);
        }
      }
      ctx.restore();

      tracks.forEach((tr,i)=>{
        const y = top + i*laneH;
        const steps = Math.max(1, Math.min(256, tr.steps|0));
        const patt = tr.pattern.length ? tr.pattern : euclidean(tr.steps, tr.hits);
        const offset = ((tr.offset%steps)+steps)%steps;

        // carril
        ctx.save();
        ctx.strokeStyle = rule; ctx.strokeRect(10, y, W-20, laneH-6);
        // dibujar steps
        const totalPx = W-20;
        const stepCount = (mode==='polyrhythm') ? steps : Math.round((4*steps)); // en polymeter, step com√∫n = negra; mostramos 1 comp√°s
        const stepW = totalPx / steps;

        for(let s=0;s<steps;s++){
          const on = patt[(s+offset)%steps];
          const x = 10 + s*stepW;
          ctx.fillStyle = on ? ink : muted;
          ctx.globalAlpha = on ? 0.9 : 0.25;
          ctx.fillRect(x+1, y+2, Math.max(2, stepW-2), laneH-10);

          // marca de acento en hat (si aplica)
          if(on && tr.sound==='hat' && tr.accent==='alt'){
            // alterna visualmente: semic√≠rculo arriba/abajo
            const k = s%2; // solo indicativo en vista
            ctx.globalAlpha = 1;
            ctx.beginPath();
            const cx = x + stepW*0.5, cy = y + (k?6: (laneH-12));
            ctx.arc(cx, cy, 3, 0, Math.PI*2);
            ctx.fillStyle = ink;
            ctx.fill();
          }
        }

        // etiqueta
        ctx.fillStyle = muted; ctx.font='12px ui-serif, Georgia, serif';
        ctx.fillText(`${tr.name} ‚Äî ${tr.steps}:${tr.hits}${tr.sound==='hat'&&tr.accent!=='none'?' (acc)':''}`, 14, y-4);
        ctx.restore();
      });

      // playhead
      ctx.save();
      const cyc = (mode==='polyrhythm') ? barDur : (60/TP)*4;
      const phase = isPlaying ? ( (elapsed % cyc) / cyc ) : 0;
      const x = 10 + phase * (W-20);
      ctx.strokeStyle = ink; ctx.globalAlpha = 0.4;
      ctx.beginPath(); ctx.moveTo(x, 10); ctx.lineTo(x, H-10); ctx.stroke();
      ctx.restore();
    }

    /* ===== Presets externos con grupos (JSON) ===== */
    const PRESET_URL = 'polyrhythm-presets.json';
    let GROUPS = [];         // [{id,label,presets:{key->obj}}]
    let FLAT_PRESETS = {};   // presets||legacy
    function populatePresetSelect(){
      const sel = $('#preset');
      [...sel.querySelectorAll('optgroup, option:not([value=""])')].forEach(n=>n.remove());

      (GROUPS||[]).forEach(g=>{
        const og = document.createElement('optgroup');
        og.label = g.label || g.id || 'Group';
        const keys = Object.keys(g.presets||{});
        keys.forEach(k=>{
          const p = g.presets[k];
          const opt = document.createElement('option');
          opt.value = `group::${g.id}::${k}`;
          const tags = (p.tags && p.tags.length) ? ` ‚Äî ${p.tags.slice(0,3).join(', ')}` : '';
          opt.textContent = (p.label || k) + tags;
          og.appendChild(opt);
        });
        if(og.children.length) sel.appendChild(og);
      });

      const flatKeys = Object.keys(FLAT_PRESETS||{});
      if(flatKeys.length){
        const og = document.createElement('optgroup');
        og.label = 'Other / Ungrouped';
        flatKeys.forEach(k=>{
          const p = FLAT_PRESETS[k];
          const opt = document.createElement('option');
          opt.value = `flat::${k}`;
          const tags = (p.tags && p.tags.length) ? ` ‚Äî ${p.tags.slice(0,3).join(', ')}` : '';
          opt.textContent = (p.label || k) + tags;
          og.appendChild(opt);
        });
        sel.appendChild(og);
      }

      if(!sel.querySelector('optgroup')){
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = 'No external presets found';
        opt.disabled = true;
        sel.appendChild(opt);
      }
    }

    async function loadExternalPresets(){
      try{
        const resp = await fetch(PRESET_URL, {cache:'no-store'});
        if(!resp.ok) throw new Error('HTTP '+resp.status);
        const data = await resp.json();
        GROUPS = Array.isArray(data.groups) ? data.groups : [];
        FLAT_PRESETS = (data && data.presets && typeof data.presets==='object') ? data.presets : {};
        populatePresetSelect();
      }catch(err){
        console.warn('Could not load external presets:', err);
        GROUPS = []; FLAT_PRESETS = {};
        populatePresetSelect();
        $('#preset').title = 'Could not load polyrhythm-presets.json (serve over HTTP, not file://)';
      }
    }

    function clearTracks(){ $('#tracks').innerHTML=''; tracks.length=0; }

    function applyPresetObject(obj){
      if(!obj) return;
      $('#tempo').value    = obj.tempo    ?? 120;
      $('#barLen').value   = obj.barLen   ?? 4;
      $('#mode').value     = obj.mode     ?? 'polymeter';
      $('#swing').value    = obj.swing    ?? 0;
      $('#instMode').value = obj.inst     ?? 'drums';
      $('#rootNote').value = obj.rootNote ?? 'E2';
      $('#swingVal').textContent = `swing: ${Math.round((obj.swing||0)*100)}%`;

      clearTracks();
      (obj.tracks||[]).forEach(t=> makeTrack(t));
      drawAll();
    }

    function findPresetByToken(token){
      if(!token) return null;
      const parts = token.split('::');
      if(parts[0]==='group' && parts.length===3){
        const gid = parts[1], key = parts[2];
        const g = GROUPS.find(x=>x.id===gid);
        return g && g.presets ? g.presets[key] : null;
      }
      if(parts[0]==='flat' && parts.length===2){
        const key = parts[1];
        return FLAT_PRESETS[key] || null;
      }
      return null;
    }

    function applyPresetByToken(token){
      const p = findPresetByToken(token);
      if(!p){ alert('Preset not found'); return; }
      applyPresetObject(p);
    }

    /* ===== Export / Import JSON (manual) ===== */
    function exportJSON(){
      const data = {
        tempo: parseFloat($('#tempo').value)||120,
        barLen: parseFloat($('#barLen').value)||4,
        mode: $('#mode').value,
        swing: parseFloat($('#swing').value)||0,
        inst: $('#instMode').value,
        rootNote: $('#rootNote').value,
        tracks: tracks.map(t=>({
          name:t.name, steps:t.steps, hits:t.hits, offset:t.offset,
          sound:t.sound, note:t.note, pan:t.pan, volume:t.volume, mute:t.mute, solo:t.solo, accent:t.accent
        }))
      };
      const txt = JSON.stringify(data, null, 2);
      navigator.clipboard?.writeText(txt).catch(()=>{});
      alert('Preset copied to clipboard.');
    }

    function importJSON(){
      const txt = prompt('Paste preset JSON:');
      if(!txt) return;
      try{
        const obj = JSON.parse(txt);
        applyPresetObject(obj);
      }catch(e){ alert('Invalid JSON'); }
    }

    /* ===== MIDI Export (SMF Type 0) ===== */
    function vlq(n){ const bytes=[]; let buffer = n & 0x7F; while((n >>= 7)){ buffer <<= 8; buffer |= ((n & 0x7F) | 0x80); } while(true){ bytes.push(buffer & 0xFF); if(buffer & 0x80) buffer >>= 8; else break; } return bytes; }
    function pushBytes(arr, ...vals){ vals.forEach(v=>arr.push(v&0xFF)); }
    function buildMIDI(){
      const tpq = 480;
      const tempoBPM = parseFloat($('#tempo').value)||120;
      const mpq = Math.round(60000000/tempoBPM);

      const mode = $('#instMode').value;
      const rootMidi = midiFromInput($('#rootNote').value||'E2');
      const rhythmMode = $('#mode').value;
      const barBeats = parseFloat($('#barLen').value)||4;
      const swing = parseFloat($('#swing').value)||0;

      const bars = 4;
      const totalBeats = barBeats * bars;

      const events = [];
      events.push({ t:0, data:[0xFF,0x51,0x03, (mpq>>16)&0xFF, (mpq>>8)&0xFF, mpq&0xFF ] });
      const num = barBeats|0, denomPow = 2;
      events.push({ t:0, data:[0xFF,0x58,0x04, num&0xFF, denomPow, 24, 8 ] });

      let nextMelCh = 0;
      function nextChannel(){ const ch = nextMelCh % 8; nextMelCh++; return ch; }
      const drumNoteMap = { kick:36, snare:38, hat:42, clave:75, click:37 };

      tracks.forEach(tr => { tr._midiCount = 0; });

      tracks.forEach(tr => {
        const steps = Math.max(1, Math.min(256, tr.steps|0));
        const patt = tr.pattern.length ? tr.pattern : euclidean(tr.steps, tr.hits);
        if(patt.reduce((a,b)=>a+b,0)===0) return;

        const soloed = tracks.some(x=>x.solo);
        const audible = (!soloed || tr.solo) && !tr.mute && tr.volume>0.001;
        if(!audible) return;

        let ch, noteNumber, program = null;
        if(mode==='drums'){
          ch = 9;
          noteNumber = drumNoteMap[tr.sound] ?? 37;
        }else{
          ch = nextChannel();
          noteNumber = tr.note ? midiFromInput(tr.note) : rootMidi;
          program = (mode==='guitar') ? 28 : 33;
          events.push({ t:0, data:[0xC0 | (ch&0x0F), program&0x7F] });
        }

        const stepDurBeats = (rhythmMode==='polyrhythm') ? (barBeats/steps) : (0.25);
        const totalSteps = Math.round(totalBeats / stepDurBeats);
        const offset = ((tr.offset%steps)+steps)%steps;

        for(let i=0;i<totalSteps;i++){
          const sIdx = (i + offset) % steps;
          if(!patt[sIdx]) continue;

          const swingOffBeats = ((i%2)===1) ? swing*(stepDurBeats*0.5) : 0;

          const tBeats = i*stepDurBeats + swingOffBeats;
          const tTicks = Math.round(tBeats * tpq);
          const durTicks = Math.max(30, Math.round(stepDurBeats * tpq * 0.5));

          let vel = Math.max(1, Math.min(127, Math.round((tr.volume||0.9)*100)+20));
          if(mode==='drums' && tr.sound==='hat' && tr.accent==='alt'){
            vel = Math.round( vel * ( (tr._midiCount%2===0) ? 0.65 : 1.0 ) );
            tr._midiCount++;
          }

          events.push({ t:tTicks, data:[0x90 | (ch&0x0F), noteNumber&0x7F, vel] });
          events.push({ t:tTicks+durTicks, data:[0x80 | (ch&0x0F), noteNumber&0x7F, 0x40] });
        }
      });

      events.sort((a,b)=> a.t!==b.t ? a.t-b.t : (a.data[0]===0x90 && b.data[0]===0x80 ? 1 : -1));

      let track = [];
      let lastT = 0;
      for(const ev of events){
        const dt = ev.t - lastT; lastT = ev.t;
        track.push(...vlq(dt), ...ev.data);
      }
      track.push(...vlq(0), 0xFF, 0x2F, 0x00);

      const header = [];
      pushBytes(header, 0x4D,0x54,0x68,0x64, 0x00,0x00,0x00,0x06, 0x00,0x00, 0x00,0x01, (tpq>>8)&0xFF, tpq&0xFF);
      const trkLen = track.length;
      const trkHeader = [0x4D,0x54,0x72,0x6B, (trkLen>>>24)&0xFF, (trkLen>>>16)&0xFF, (trkLen>>>8)&0xFF, trkLen&0xFF];

      const bytes = new Uint8Array([...header, ...trkHeader, ...track]);
      const blob = new Blob([bytes], {type:'audio/midi'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `PolyrhythmForge_${tempoBPM}bpm_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.mid`;
      document.body.appendChild(a); a.click(); a.remove();
    }

    /* ===== Wire UI ===== */
    $('#play').addEventListener('click', () => { if(!isPlaying){ start(); } });
    $('#stop').addEventListener('click', stop);
    $('#addTrack').addEventListener('click', () => { makeTrack({ name:`Track ${tracks.length+1}`, steps:16, hits:8, sound:'click' }); drawAll(); });
    $('#preset').addEventListener('change', e => { const tok=e.target.value; if(tok) applyPresetByToken(tok); e.target.value=''; });
    $('#export').addEventListener('click', exportJSON);
    $('#import').addEventListener('click', importJSON);
    $('#exportMidi').addEventListener('click', buildMIDI);
    $('#swing').addEventListener('input', e => { const v=parseFloat(e.target.value)||0; $('#swingVal').textContent = `swing: ${Math.round(v*100)}%`; });

    const resumeOnce = ()=>{ try{ getAC(); }catch(e){} window.removeEventListener('pointerdown', resumeOnce, {capture:true}); window.removeEventListener('keydown', resumeOnce, {capture:true}); };
    window.addEventListener('pointerdown', resumeOnce, {capture:true, once:true});
    window.addEventListener('keydown', resumeOnce, {capture:true, once:true});

    (async function init(){
      await loadExternalPresets();
      // estado inicial
      makeTrack({ name:'Kick',  steps:16, hits:4,  sound:'kick',  pan:-0.05, volume:1.0 });
      makeTrack({ name:'Snare', steps:16, hits:4,  offset:8, sound:'snare', pan:0,    volume:0.9 });
      makeTrack({ name:'Hat',   steps:16, hits:8,  sound:'hat',   pan:0.1,  volume:0.6, accent:'alt' });
      drawAll();
    })();
  </script>
</body>
</html>